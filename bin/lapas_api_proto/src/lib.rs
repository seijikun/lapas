pub mod proto;
pub use proto::*;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

pub type Version = u32;
pub const VERSION: Version = 4;

#[derive(Debug, Clone)]
pub enum ApiPassword {
    /// Plaintext LAPAS administration password
    Plain(String),
    /// Root Nonce meant for root-user login.
    /// This is an authentication password that is automatically generated by lapas-api-server at every startup.
    RootNonce(String)
}
#[async_trait::async_trait]
impl ProtoSerde for ApiPassword {
    async fn decode<R: AsyncReadExt + Send + Unpin>(reader: &mut R) -> Result<Self, LapasProtocolError> {
        let tag = reader.read_u8().await?;
        match tag {
            0 => Ok(ApiPassword::Plain( String::decode(reader).await? )),
            1 => Ok(ApiPassword::RootNonce( String::decode(reader).await? )),
            _ => Err(LapasProtocolError::ProtocolError("Error while deserializing ApiPassword. Invalid Tag".to_owned()))
        }
    }
    async fn encode<W: AsyncWriteExt + Send + Unpin>(&self, writer: &mut W) -> Result<(), LapasProtocolError> {
        match self {
            ApiPassword::Plain(password) => {
                writer.write_u8(0).await?;
                password.encode(writer).await?;
            },
            ApiPassword::RootNonce(password) => {
                writer.write_u8(1).await?;
                password.encode(writer).await?;
            }
        }
        Ok(())
    }
}



define_protocol!(proto LapasProtocol {
    ResponseResult {
        result: Result<(), String>
    },

    RequestHello {
        version: Version,
        // Optionally sha512 hex-string of the administration unsalted password
        password: ApiPassword
    },
    RequestPing {},
    RequestAddUser {
        username: String,
        password: String
    },
    // Tell the server that he should now create a dns mapping for the given user
    // to the ip address from which this requests is comming
    RequestDnsMapping {
        username: String
    },

    // switch to notify mode. After sending this package (client -> server), the
    // connection can only be used to receive notifications from the server
    SwitchNotify {},
    // Packet notifying tuests that they should remount their root filesystem because
    // some files have changed (takes a remount to avoid stale file handle errors with overlayfs)
    NotifyRootChanged {},
    // Packet notifying guests that they should now clear their dns cache because some
    // mappings have changed
    NotifyDnsMappingsChanged {}
});